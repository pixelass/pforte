{"mappings":"ACcA,0BAA0B,QAAQ,KAAA,EAAE,MAAM,KAAA,QAYzC;AAED,8BAA8B,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE;;;;CAAA;;;;;;;;;;;;EA8B1D;AAED,8BAAoC,EAAE,OAAO,EAAE;;CAAA,EAAE,OAAO,KAAA,gBAevD;AAED,8BAA8B,EAAE,QAAQ,EAAE;;CAAA,QAiBzC;AAED,+BAA+B,EAAE,OAAO,EAAE,SAAS,EAAE,MAAwB,EAAE;;;;CAAA,kDAwE9E","sources":["packages/core/src/src/csrf-token.ts","packages/core/src/src/index.ts","packages/core/src/index.ts"],"sourcesContent":[null,null,"import process from \"node:process\";\n\nimport {\n\tAUTH_CSRF_COOKIE,\n\tAUTH_SESSION_COOKIE,\n\tCALLBACK_PATH,\n\tDEFAULT_MAX_AGE,\n} from \"@pforte/constants\";\nimport { getExpirationDate } from \"@pforte/utils\";\nimport { serialize } from \"cookie\";\nimport { nanoid } from \"nanoid\";\n\nimport createCSRFToken from \"./csrf-token\";\n\nexport function setCookie(response, cookie) {\n\t// Preserve any existing cookies that have already been set in the same session\n\tlet setCookieHeader = response.getHeader(\"Set-Cookie\") ?? [];\n\t// If not an array (i.e. a string with a single cookie) convert to array\n\tif (!Array.isArray(setCookieHeader)) {\n\t\tsetCookieHeader = [setCookieHeader];\n\t}\n\tconst { name, value, options } = cookie;\n\tconst cookieHeader = serialize(name, value, options);\n\n\tsetCookieHeader.push(cookieHeader);\n\tresponse.setHeader(\"Set-Cookie\", setCookieHeader);\n}\n\nexport function extendHandler({ request, response, maxAge }) {\n\tconst cookies = Object.entries(request.cookies).map(([name, value]) => ({\n\t\tname,\n\t\tvalue,\n\t\toptions: {},\n\t}));\n\tconst sessionToken = nanoid();\n\tconst csrfToken = createCSRFToken({\n\t\toptions: { secret: process.env.PFORTE_SECRET || \"pforte-secret\" },\n\t\tisPost: false,\n\t});\n\tconst expires = getExpirationDate(maxAge);\n\tcookies.push({\n\t\tname: AUTH_SESSION_COOKIE,\n\t\tvalue: sessionToken,\n\t\toptions: {\n\t\t\tpath: \"/\",\n\t\t\texpires,\n\t\t},\n\t});\n\tcookies.push({\n\t\tname: AUTH_CSRF_COOKIE,\n\t\tvalue: csrfToken.cookie,\n\t\toptions: {\n\t\t\tpath: \"/\",\n\t\t\texpires,\n\t\t},\n\t});\n\tcookies.forEach(cookie => setCookie(response, cookie));\n\treturn { sessionToken, csrfToken, expires };\n}\n\nexport async function handleSession({ request }, adapter) {\n\tif (adapter) {\n\t\tconst { sessionToken, csrfToken } = request.body;\n\t\tconst [bodyValue] = csrfToken.split(\"|\");\n\t\tconst { csrfTokenVerified } = createCSRFToken({\n\t\t\toptions: { secret: process.env.PFORTE_SECRET || \"pforte-secret\" },\n\t\t\tisPost: true,\n\t\t\tcookieValue: csrfToken,\n\t\t\tbodyValue,\n\t\t});\n\n\t\treturn csrfTokenVerified ? await adapter(\"session\", { sessionToken, csrfToken }) : null;\n\t} else {\n\t\treturn null;\n\t}\n}\n\nexport function handleSignOut({ response }) {\n\tsetCookie(response, {\n\t\tname: AUTH_SESSION_COOKIE,\n\t\tvalue: \"\",\n\t\toptions: {\n\t\t\tpath: \"/\",\n\t\t\texpires: getExpirationDate(0),\n\t\t},\n\t});\n\tsetCookie(response, {\n\t\tname: AUTH_CSRF_COOKIE,\n\t\tvalue: \"\",\n\t\toptions: {\n\t\t\tpath: \"/\",\n\t\t\texpires: getExpirationDate(0),\n\t\t},\n\t});\n}\n\nexport default function pforte({ adapter, providers, maxAge = DEFAULT_MAX_AGE }) {\n\tconst host = process.env.PFORTE_URL || process.env.VERCEL_URL || \"http://localhost:3000\";\n\tconst callbackPath = [host, CALLBACK_PATH].join(\"/\");\n\n\treturn async function pforteHandler(request, response) {\n\t\tconst { query } = request;\n\t\tswitch (query.pforte) {\n\t\t\tcase \"session\":\n\t\t\t\tawait handleSession({ request }, adapter).then(user => {\n\t\t\t\t\tresponse.status(200).json({\n\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\tdata: user\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t\t\tid: user._id,\n\t\t\t\t\t\t\t\t\t\tname: user.name,\n\t\t\t\t\t\t\t\t\t\temail: user.email,\n\t\t\t\t\t\t\t\t\t\timage: user.image,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t: null,\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase \"signin\":\n\t\t\t\tresponse.status(200).json({\n\t\t\t\t\turl: providers.find(provider_ => provider_.name === query.provider).url,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase \"signout\":\n\t\t\t\thandleSignOut({ response });\n\t\t\t\tresponse.status(302).setHeader(\"Location\", callbackPath).end();\n\t\t\t\tbreak;\n\t\t\tcase \"callback\":\n\t\t\t\tresponse.status(302).setHeader(\"Location\", host).end();\n\t\t\t\tbreak;\n\t\t\tcase \"github\":\n\t\t\t\ttry {\n\t\t\t\t\tconst provider = providers.find(provider_ => provider_.name === \"github\");\n\t\t\t\t\tawait provider\n\t\t\t\t\t\t.connect({ request })\n\t\t\t\t\t\t.then(({ user, accessToken }) => {\n\t\t\t\t\t\t\tif (adapter) {\n\t\t\t\t\t\t\t\tconst { sessionToken, csrfToken } = extendHandler({\n\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\tresponse,\n\t\t\t\t\t\t\t\t\tmaxAge,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\treturn adapter(\"user\", {\n\t\t\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\t\t\taccessToken,\n\t\t\t\t\t\t\t\t\tsessionToken,\n\t\t\t\t\t\t\t\t\tcsrfToken,\n\t\t\t\t\t\t\t\t\tmaxAge,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\tresponse.status(302).setHeader(\"Location\", callbackPath).end();\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\t\tresponse.status(error.response.status).send(error.message);\n\t\t\t\t\t\t});\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(error);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tresponse.status(404).send(\"Not Found\");\n\t\t\t\tbreak;\n\t\t}\n\t};\n}\n"],"names":[],"version":3,"file":"types.d.ts.map"}